#!/usr/bin/env perl

use 5.20.1;
use warnings;

use File::Slurp qw( read_file );
use Function::Parameters qw( :strict );
use Term::ReadLine;
use Try::Tiny;

use FindBin ();
use lib "$FindBin::Bin/../lib";

use MAL::Environment;
use MAL::Object;
use MAL::Reader;

my $global_env = MAL::Environment->new;
my $term;

my %special_form = (
    'def!' => fun($args, $env) {
        my $symbol = $args->item(0)->value;
        my $value = EVAL($args->item(1), $env);
        return $env->set($symbol, $value);
    },
    'set!' => fun($args, $env) {
        my $symbol = $args->item(0)->value;
        my $symenv = $env->find($symbol);
        die "$symbol not found" unless $symenv;
        my $value = EVAL($args->item(1), $env);
        return $symenv->set($symbol, $value);
    },
    'defmacro!' => fun($args, $env) {
        my $symbol = $args->item(0)->value;
        my $value = EVAL($args->item(1), $env);
        return $env->set($symbol,
            $value->with_meta(
                MAL::Object->hash(
                    MAL::Object->string("ismacro"),
                    MAL::Object->true,
                )
            ));
    },
    'let*' => fun($args, $env) {
        my $inner_env = MAL::Environment->new(outer => $env);
        my @bindings = $args->item(0)->items;
        while (@bindings) {
            $inner_env->set($bindings[0]->to_string,
                            EVAL($bindings[1], $inner_env));
            splice(@bindings, 0, 2);
        }
        my $expression = $args->item(1);
        return ($expression, $inner_env);
    },
    'do' => fun($args, $env) {
        my @args = $args->items;
        my $last = pop @args;
        EVAL($_, $env) for @args;
        return ($last, $env);
    },
    'if' => fun($args, $env) {
        my ($condition, $consequent, $alternative) = $args->items;
        my $result = EVAL($condition, $env);
        if (! ($result->is_false || $result->is_nil)) {
            return ($consequent, $env);
        }
        else {
            if (! defined($alternative)) {
                return MAL::Object->nil;
            }
            return ($alternative, $env);
        }
    },
    'fn*' => fun($args, $env) {
        my ($parameters, $expression) = $args->items;
        return MAL::Object->lambda($parameters, $expression, $env);
    },
    'quote' => fun($args, $env) {
        return $args->car;
    },
    'quasiquote' => fun($args, $env) {
        return ( quasiquote($args->first), $env );
    },
    'macroexpand' => fun($args, $env) {
        return macro_expand($args->first, $env);
    },
    'try*' => fun($args, $env) {
        my ($try, $catch) = $args->items;
        my $ret = try {
            EVAL($try, $env);
        }
        catch {
            my $exc_value = $_;
            if (!ref $exc_value) {
                chomp $exc_value;
                $exc_value = MAL::Object->string($exc_value);
            }
            my ($sym, $exc_sym, $code) = $catch->items;
            my $handler = MAL::Object->lambda(
                MAL::Object->list($exc_sym), $code, $env);
            EVAL($handler->apply(MAL::Object->list($exc_value)));
        };
        return $ret;
    },
);

my @builtins = (
    [ '+', integer => sub {
        reduce(sub { $_[0] + $_[1] }, 0, map { $_->value } @_)
    }],
    [ '-', integer => sub {
        @_ == 1 ? -$_[0] : reduce(sub { $_[0] - $_[1] }, map { $_->value } @_)
    }],
    [ '*', integer => sub {
        reduce(sub { $_[0] * $_[1] }, 1, map { $_->value } @_)
    }],
    [ '/', integer => sub {
        reduce(sub { int($_[0] / $_[1]) }, map { $_->value } @_)
    }],
    [ 'list', list => sub { @_ } ],
    [ 'list?', boolean => fun($a) { $a->is_list } ],
    [ 'symbol?', boolean => fun($a) { $a->is_symbol } ],
    [ 'keyword?', boolean => fun($a) { $a->is_keyword } ],
    [ 'nil?',   boolean => fun($a) { $a->is_nil } ],
    [ 'true?',  boolean => fun($a) { $a->is_true } ],
    [ 'false?', boolean => fun($a) { $a->is_false } ],
    [ 'sequential?', boolean => fun($a) { $a->is_sequence } ],
    [ 'vector?', boolean => fun($a) { $a->is_vector } ],
    [ 'map?', boolean => fun($a) { $a->is_hash } ],
    [ 'empty?', boolean => fun($a) {
        return $a->is_sequence && (scalar($a->items) == 0);
    }],
    [ 'count', integer => fun($a) {
        return 0 unless $a->is_sequence;
        return scalar($a->items);
    }],
    [ '=', boolean  => fun($a, $b) { $a->equal($b) } ],
    [ '<',  boolean => fun($a, $b) { $a->value <  $b->value } ],
    [ '<=', boolean => fun($a, $b) { $a->value <= $b->value } ],
    [ '>',  boolean => fun($a, $b) { $a->value >  $b->value } ],
    [ '>=', boolean => fun($a, $b) { $a->value >= $b->value } ],
    [ 'str', string => sub { join('', map { $_->to_string } @_) }],
    [ 'pr-str', string => sub { join(' ', map { $_->to_string(1) } @_) }],
    [ 'prn', nil => sub { say join(' ', map { $_->to_string(1) } @_) }],
    [ 'println', nil => sub { say join(' ', map { $_->to_string } @_) }],
    [ 'read-string', undef, fun(MAL::Object::String $str) { READ($str->value) }],
    [ 'eval', undef, fun($str) { EVAL($str, $global_env) }],
    [ 'slurp',  string => fun($fname) { scalar(read_file($fname->value)) }],
    [ 'cons', list => fun($car, $cdr) { return ( $car, $cdr->items ) }],
    [ 'concat', list => sub { return map { $_->items } @_ }],
    [ 'nth', undef, fun(MAL::Object::Sequence $seq, $index) {
        $index = $index->value;
        if ($index < 0 || $index >= $seq->length) {
            die "Index out of range\n";
        }
        return $seq->item($index);
    }],
    [ 'first', undef, fun(MAL::Object::Sequence $seq) {
        is_pair($seq) ? $seq->first : MAL::Object->nil
    }],
    [ 'rest',  undef, fun(MAL::Object::Sequence $seq) { $seq->rest->to_list }],
    [ 'throw', undef, fun($msg) { die $msg }],
    [ 'apply', undef, fun(MAL::Object::Applyable $op, @args) {
        my $lastarg = pop(@args);
        my $arglist = MAL::Object->list(@args, $lastarg->items);
        return $op->apply($arglist);
    }],
    [ 'symbol', symbol => fun(MAL::Object::String $str) { return $str->value }],
    [ 'keyword', keyword => fun(MAL::Object::String $str) { return ':' . $str->value }],
    [ 'vector', vector => sub { return @_ }],
    [ 'hash-map', hash => sub { return @_ }],
    [ 'assoc', undef, fun(MAL::Object::Hash $hash, @pairs) { $hash->assoc(@pairs) }],
    [ 'dissoc', undef, fun(MAL::Object::Hash $hash, @pairs) { $hash->dissoc(@pairs) }],
    [ 'get', undef, fun($hash, $key) {
        return $hash->is_hash ? $hash->get($key) : MAL::Object->nil;
    }],
    [ 'contains?', boolean => fun(MAL::Object::Hash $hash, $key) { $hash->contains($key) } ],
    [ 'keys', list => fun(MAL::Object::Hash $hash) { map { READ($_) } $hash->get_keys } ],
    [ 'vals', list => fun(MAL::Object::Hash $hash) { $hash->get_vals } ],
    [ 'with-meta', undef, fun($obj, $meta) { return $obj->with_meta($meta) }],
    [ 'meta', undef, fun($obj) { return $obj->meta }],
    [ 'atom', atom => fun($obj) { return $obj }],
    [ 'atom?', boolean => fun($obj) { return $obj->is_atom }],
    [ 'deref', undef, fun($atom) { return $atom->deref }],
    [ 'reset!', undef, fun($atom, $value) { return $atom->reset($value) }],
    [ 'conj', undef, fun(MAL::Object::Sequence $seq, @items) { return $seq->conj(@items) }],
    [ 'readline', undef, fun($prompt) {
        my $input = $term->readline($prompt->to_string);
        return MAL::Object->nil unless defined $input;
        chomp $input;
        return MAL::Object->string($input);
    }],
);

my @library = (
    '(def! *host-language* "sdt-perl")',
    '(def! not (fn* (x) (if x false true)))',
    '(def! load-file (fn* (f) (eval (read-string (str "(do " (slurp f) ")")))))',
    "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))",
    "(defmacro! or (fn* (& xs) (if (empty? xs) nil (if (= 1 (count xs)) (first xs) `(let* (or_FIXME ~(first xs)) (if or_FIXME or_FIXME (or ~@(rest xs))))))))",
    '(def! map (fn* (f xs) (if (empty? xs) xs (cons (f (first xs)) (map f (rest xs))))))',
    '(defmacro! swap! (fn* (atom f & args) `(reset! ~atom (~f (deref ~atom) ~@args))))',
);

exit main(@ARGV) ? 0 : 1;

#-------------------------------------------------------------------------------

fun main(@argv) {
    $term = Term::ReadLine->new('mal');
    $term->ornaments(0);
    my $prompt = 'user> ';
    for (@builtins) {
        my ($sym, $type, $coderef) = @$_;
        $global_env->set($sym, MAL::Object->builtin($sym, $coderef, $type));
    }
    for (@library) {
        rep($_, $global_env);
    }
    my ($filename, @args) = @argv;
    $global_env->set('*ARGV*',
        MAL::Object->list(map { MAL::Object->string($_) } @args)
    );
    if ($filename) {
        say rep("(load-file \"$filename\")", $global_env);
    }
    else {
        while (defined(my $input = $term->readline($prompt))) {
            chomp($input);
            try {
                say rep($input, $global_env);
            }
            catch {
                chomp;
                say $_;
            };
            $term->addhistory($input) if $input =~ /\S/;
        }
    }
    return 1;
}

fun rep($input, $env) {
    return PRINT(EVAL(READ($input), $env));
}

fun READ($input) {
    return MAL::Reader->read_str($input);
}

fun EVAL($ast, $env) {
    while (1) {
        if (!$ast->is_list) {
            return eval_ast($ast, $env);
        }
        $ast = macro_expand($ast, $env);
        if (!is_pair($ast)) {
            return $ast;
        }

        my $op = $ast->car;
        if ($op->is_symbol && (my $special = $special_form{$op->value})) {
            ($ast, $env) = $special->($ast->cdr, $env);
        }
        else {
            $ast = eval_ast($ast, $env);
            ($ast, $env) = $ast->car->apply($ast->cdr);
        }
        next if $env; # TCO
        return $ast;
    }
}

fun eval_ast($ast, $env) {
    if ($ast->is_symbol) {
        return $env->get($ast->value);
    }
    if ($ast->is_sequence) {
        return $ast->map_items(sub { EVAL($_[0], $env) });
    }
    if ($ast->is_hash) {
        return $ast->map_values(sub { EVAL($_[0], $env) });
    }
    return $ast;
}

fun PRINT($ast) {
    return $ast->to_string(1);
}

fun reduce($op, $base, @list) {
    $base = $op->($base, $_) for @list;
    return $base;
}

fun is_pair($ast) {
    return $ast->is_sequence && ($ast->length > 0);
}

fun is_symbol($ast, $text) {
    return $ast->is_symbol && ($ast->value eq $text);
}

fun is_macro_call($ast, $env) {
    return unless is_pair($ast);
    return unless $ast->first->is_symbol;
    my $value = $env->safe_get($ast->first->value);
    return unless $value && $value->is_lambda && $value->is_macro;
    return $value;
}

fun macro_expand($ast, $env) {
    while (my $macro = is_macro_call($ast, $env)) {
        $ast = EVAL($macro->apply($ast->rest));
    }
    return $ast;
}

fun make_form($symbol, @args) {
    return MAL::Object->list(
        MAL::Object->symbol($symbol),
        @args,
    );
}

fun quasiquote($ast) {
    if (!is_pair($ast)) {
        return make_form(quote => $ast);
    }
    if (is_symbol($ast->first, 'unquote')) {
        return $ast->item(1);
    }
    if (is_pair($ast->first) &&
        is_symbol($ast->first->item(0), 'splice-unquote')) {
        return make_form(concat =>
            $ast->first->item(1),
            quasiquote($ast->rest),
        );
    }
    return make_form(cons =>
        quasiquote($ast->first),
        quasiquote($ast->rest)
    );
}
