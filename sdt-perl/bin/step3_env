#!/usr/bin/env perl

use 5.20.1;
use warnings;

use Function::Parameters qw( :strict );
use Term::ReadLine;

use FindBin ();
use lib "$FindBin::Bin/../lib";

use MAL::Environment;
use MAL::Object;
use MAL::Reader;

exit main(@ARGV) ? 0 : 1;

#-------------------------------------------------------------------------------

fun main(@argv) {
    my $term = Term::ReadLine->new('mal');
    my $prompt = 'user> ';
    my $global_env = MAL::Environment->new(data => {
        '+' => MAL::Object->builtin('+',
            sub { reduce(sub { $_[0] + $_[1] }, 0, map { $_->value } @_) },
            'integer',
        ),
        '-' => MAL::Object->builtin('+',
            sub {
                @_ == 1 ? -$_[0] : reduce(sub { $_[0] - $_[1] },
                    map { $_->value } @_) },
            'integer',
        ),
        '*' => MAL::Object->builtin('*',
            sub { reduce(sub { $_[0] * $_[1] }, 1,  map { $_->value } @_) },
            'integer',
        ),
        '/' => MAL::Object->builtin('/',
            sub { reduce(sub { int($_[0] / $_[1]) },  map { $_->value } @_) },
            'integer',
        ),
    });
    while (defined(my $input = $term->readline($prompt))) {
        chomp($input);
        eval { say rep($input, $global_env) };
        print $@ if $@;
        $term->addhistory($input) if $input =~ /\S/;
    }
    return 0;
}

fun rep($input, $env) {
    return PRINT(EVAL(READ($input), $env));
}

fun READ($input) {
    return MAL::Reader->read_str($input);
}

fun EVAL($ast, $env) {
    if ($ast->is_list) {
        if ($ast->car->is_symbol) {
            my $operator = $ast->car->value;
            my $args = $ast->cdr;
            if ($operator eq 'def!') {
                my $symbol = $args->car->value;
                my $value = EVAL($args->cdr->car, $env);
                return $env->set($symbol, $value);
            }
            if ($operator eq 'let*') {
                my $inner_env = MAL::Environment->new(outer => $env);
                my @bindings = $args->car->items;
                while (@bindings) {
                    $inner_env->set($bindings[0]->to_string,
                                    EVAL($bindings[1], $inner_env));
                    splice(@bindings, 0, 2);
                }
                my $expression = $args->cdr->car;
                return EVAL($expression, $inner_env);
            }
        }
        $ast = eval_ast($ast, $env);
        my $op = $ast->car;
        my $args = $ast->cdr;
        return $op->apply($args);
    }
    return eval_ast($ast, $env);
}

fun eval_ast($ast, $env) {
    if ($ast->is_symbol) {
        return $env->get($ast->value);
    }
    if ($ast->is_sequence) {
        return $ast->map_items(sub { EVAL($_[0], $env) });
    }
    if ($ast->is_hash) {
        return $ast->map_values(sub { EVAL($_[0], $env) });
    }
    return $ast;
}

fun PRINT($ast) {
    return $ast->to_string;
}

fun reduce($op, $base, @list) {
    $base = $op->($base, $_) for @list;
    return $base;
}
