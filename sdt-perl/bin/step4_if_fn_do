#!/usr/bin/env perl

use 5.20.1;
use warnings;

use Function::Parameters qw( :strict );
use Term::ReadLine;

use FindBin ();
use lib "$FindBin::Bin/../lib";

use MAL::Environment;
use MAL::Object;
use MAL::Reader;

my %special_form = (
    'def!' => fun($args, $env) {
        my $symbol = $args->car->value;
        my $value = EVAL($args->cdr->car, $env);
        return $env->set($symbol, $value);
    },
    'let*' => fun($args, $env) {
        my $inner_env = MAL::Environment->new(outer => $env);
        my @bindings = $args->car->items;
        while (@bindings) {
            $inner_env->set($bindings[0]->to_string,
                            EVAL($bindings[1], $inner_env));
            splice(@bindings, 0, 2);
        }
        my $expression = $args->cdr->car;
        return EVAL($expression, $inner_env);
    },
    'do' => fun($args, $env) {
        my $ret = MAL::Object->nil;
        for my $expression ($args->items) {
            $ret = EVAL($expression, $env);
        }
        return $ret;
    },
    'if' => fun($args, $env) {
        my $condition = $args->car;
        my $result = EVAL($condition, $env);
        if (! ($result->is_false || $result->is_nil)) {
            my $consequent = $args->cdr->car;
            return EVAL($consequent, $env);
        }
        else {
            if ($args->cdr->cdr->is_nil) {
                return MAL::Object->nil;
            }
            my $alternative = $args->cdr->cdr->car;
            return EVAL($alternative, $env);
        }
    },
    'fn*' => fun($args, $env) {
        my $parameters = $args->car;
        my $expression = $args->cdr->car;
        return MAL::Object->lambda($parameters, $expression, $env, \&EVAL);
    },
);

my %builtin = (
    '+' => MAL::Object->builtin('+',
        sub { reduce(sub { $_[0] + $_[1] }, 0, map { $_->value } @_) },
        'integer',
    ),
    '-' => MAL::Object->builtin('+',
        sub { @_ == 1 ? -$_[0]
                      : reduce(sub { $_[0] - $_[1] }, map { $_->value } @_) },
        'integer',
    ),
    '*' => MAL::Object->builtin('*',
        sub { reduce(sub { $_[0] * $_[1] }, 1, map { $_->value } @_) },
        'integer',
    ),
    '/' => MAL::Object->builtin('/',
        sub { reduce(sub { int($_[0] / $_[1]) }, map { $_->value } @_) },
        'integer',
    ),
    'list' => MAL::Object->builtin('list', sub { @_ }, 'list'),
    'list?' => MAL::Object->builtin('list?',
        sub { $_[0]->is_pair || $_[0]->is_nil },
        'boolean',
    ),
);

exit main(@ARGV) ? 0 : 1;

#-------------------------------------------------------------------------------

fun main(@argv) {
    my $term = Term::ReadLine->new('mal');
    my $prompt = 'user> ';
    my $global_env = MAL::Environment->new(data => \%builtin);
    while (defined(my $input = $term->readline($prompt))) {
        chomp($input);
        eval { say rep($input, $global_env) };
        print $@ if $@;
        $term->addhistory($input) if $input =~ /\S/;
    }
    return 0;
}

fun rep($input, $env) {
    return PRINT(EVAL(READ($input), $env));
}

fun READ($input) {
    return MAL::Reader->read_str($input);
}

fun EVAL($ast, $env) {
    if ($ast->is_pair) {
        if ($ast->car->is_symbol) {
            if (my $special = $special_form{$ast->car->value}) {
                return $special->($ast->cdr, $env);
            }
        }
        $ast = eval_ast($ast, $env);
        my $op = $ast->car;
        my $args = $ast->cdr;
        return $op->apply($args);
    }
    return eval_ast($ast, $env);
}

fun eval_ast($ast, $env) {
    if ($ast->is_symbol) {
        return $env->get($ast->value);
    }
    if ($ast->is_pair) {
        return MAL::Object->pair(
            EVAL($ast->car, $env),
            eval_ast($ast->cdr, $env),
        );
    }
    if ($ast->is_vector) {
        return MAL::Object->vector(
            map { EVAL($_, $env) } $ast->items
        );
    }
    if ($ast->is_hash) {
        return $ast->map_values(sub { EVAL($_[0], $env) });
    }
    return $ast;
}

fun PRINT($ast) {
    return $ast->to_string;
}

fun reduce($op, $base, @list) {
    $base = $op->($base, $_) for @list;
    return $base;
}
